---
{"dg-publish":true,"permalink":"/reference/righting-software-juval-loewy-highlights/","title":"Righting Software","tags":["âœ‚ï¸","ðŸ“š"],"created":"2024-08-29T16:40:14.898-05:00","updated":"2024-09-08T17:56:36.000-05:00"}
---

# Righting Software

![cover|150](https://m.media-amazon.com/images/I/51JOQUhq9ML._SY160.jpg)
## Metadata

## Highlights
#ðŸ“«
### Preface
### 1. The Method
>[!QUOTE]  
>The Zen of Architects1 simply states that for the beginner architect, there are many options of doing pretty much anything. For the master architect, however, there are only a few good options, and typically only one. 1. https://en.wikipedia.org/wiki/Zen_Mind,_Beginnerâ€™s_Mind ([LocationÂ 501](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=501)) #âœ‚ï¸ 
{ #ref-518217434}


---
#### What Is The Method?
>[!QUOTE]  
>The Method is a simple and effective analysis and design technique. You can express The Method as a formula: The Method = System Design + Project Design With system design, The Method lays out a way of breaking down a big system into small modular components. The Method offers guidelines for the structure, role, and semantics of the components and how these components should interact. The result is the architecture of the system. With project design, The Method helps you provide management with several options for building the system. Each option is some combination of schedule, cost, and risk. Each option also serves as the system assembly instructions, and it sets up the project for execution and tracking. ([LocationÂ 529](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=529)) #âœ‚ï¸ 
{ #ref-518217435}


---
>[!QUOTE]  
>Project design is the second part of the book and is far more important for success than system design. ([LocationÂ 535](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=535)) #âœ‚ï¸ 
{ #ref-518217436}


---
>[!QUOTE]  
>Design validation is critical because an organization should not risk having a team start developing against an inadequate architecture or developing a system the organization cannot afford to build. ([LocationÂ 542](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=542)) #âœ‚ï¸ 
{ #ref-518217437}


---
>[!QUOTE]  
>Early validation of the design is imperative. ([LocationÂ 551](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=551)) #âœ‚ï¸ 
{ #ref-518217438}


---
>[!QUOTE]  
>Ideally, one week into the project, you must know if the architecture is going to hold water (or not). ([LocationÂ 552](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=552)) #âœ‚ï¸ 
{ #ref-518217439}


---
>[!QUOTE]  
>Note that I am referring here to the system design, the architecture, not the detailed design of the system. Detailed design produces for each component in the architecture the key implementation artifacts, such as interfaces, class hierarchies, and data contracts. Detailed design takes longer to produce, can be done during the project execution, and may change as the system is constructed or evolved. ([LocationÂ 554](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=554)) #âœ‚ï¸ 
{ #ref-518217440}


---
>[!QUOTE]  
>Similarly, you must validate your project design. Running out of time or running over budget (or both) mid-project is simply unacceptable. ([LocationÂ 558](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=558)) #âœ‚ï¸ 
{ #ref-518217441}


---
>[!QUOTE]  
>No project should fail because it did not have enough time or resources from the start. This book shows you how to accurately calculate the project duration and costs and how to drive educated decisions. ([LocationÂ 563](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=563)) #âœ‚ï¸ 
{ #ref-518217442}


---
>[!QUOTE]  
>Using The Method, you can produce an entire system design in mere days, typically in three to five days, with project design taking similar time. ([LocationÂ 565](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=565)) #âœ‚ï¸ 
{ #ref-518217443}


---
>[!QUOTE]  
>In general, design is not time-consuming (as opposed to implementation). Building architects charge hourly and often work only a week or two at most designing a house. Constructing a house from the architectâ€™s design might take an agonizing two to three years of working with contractors, and yet the architect did not take long to produce the architecture. ([LocationÂ 572](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=572)) #âœ‚ï¸ 
{ #ref-518217444}


---
>[!QUOTE]  
>The time crunch also helps avoid design gold plating. Parkinsonâ€™s law2 states that work always expands to fill the allotted time. Given 10 days to complete a design that could be completed in five days, the architect will likely work on the design for 10 days. ([LocationÂ 575](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=575)) #âœ‚ï¸ 
{ #ref-518217445}


---
>[!QUOTE]  
>2. Cyril N. Parkinson, â€œParkinsonâ€™s Law,â€ The Economist (November 19, 1955). ([LocationÂ 579](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=579)) #âœ‚ï¸ 
{ #ref-518217446}


---
>[!QUOTE]  
>Analysis-paralysis is a predicament that occurs when someone (or a group) who is otherwise capable, clever, and even hardworking (as are most software architects) is stuck in a seemingly endless cycle of analysis, design, new revelations, and back to more analysis. ([LocationÂ 582](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=582)) #âœ‚ï¸ 
{ #ref-518217447}


---
>[!QUOTE]  
>The main reason for the paralysis is being unaware of the design decision tree for both the system and the project. The design decision tree is a general concept that applies to all design tasks, not just in software engineering. The design of any complex entity is a collection of many smaller design decisions, arranged hierarchically in a tree-like structure. ([LocationÂ 585](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=585)) #âœ‚ï¸ 
{ #ref-518217448}


---
>[!QUOTE]  
>Invariably, at some point, a downstream design decision will invalidate a prior decision; all decisions made in between these two points will be invalid. Designing this way is akin to performing a bubble sort of the design decision tree. Since bubble sort roughly involves as many operations as the square of the number of elements involved, the penalty is severe. ([LocationÂ 591](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=591)) #âœ‚ï¸ 
{ #ref-518217449}


---
>[!QUOTE]  
>Only after you have designed the system is there any point in designing the project to build that system. ([LocationÂ 602](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=602)) #âœ‚ï¸ 
{ #ref-518217450}


---
>[!QUOTE]  
>One of the most valuable techniques in pruning the decision tree is the application of constraints. As pointed by Dr. Fredrick Brooks,3 contrary to common wisdom or intuition, the worst design problem is a clean canvas. ([LocationÂ 605](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=605)) #âœ‚ï¸ 
{ #ref-518217451}


---
>[!QUOTE]  
>3. Frederick P. Brooks Jr., The Design of Design: Essays from a Computer Scientist (Upper Saddle River, NJ: Addison-Wesley, 2010). ([LocationÂ 612](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=612)) #âœ‚ï¸ 
{ #ref-518217452}


---
#### What The Method Is Not
### Part I: System Design
#### 2. Decomposition
>[!QUOTE]  
>Software architecture is the high-level design and structure of the software system. ([LocationÂ 654](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=654)) #âœ‚ï¸ 
{ #ref-518217453}


---
>[!QUOTE]  
>The act of identifying the constituent components of a system is called system decomposition. ([LocationÂ 658](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=658)) #âœ‚ï¸ 
{ #ref-518217454}


---
>[!QUOTE]  
>In a modern system and in this book, services (as in service-orientation) are the most granular unit of the architecture. However, the technology used to implement the components and their details (such as interfaces, operations, and class hierarchies) are detailed design aspects, not system decomposition. ([LocationÂ 662](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=662)) #âœ‚ï¸ 
{ #ref-518217455}


---
##### Avoid Functional Decomposition
>[!QUOTE]  
>Functional decomposition decomposes a system into its building blocks based on the functionality of the system. ([LocationÂ 670](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=670)) #âœ‚ï¸ 
{ #ref-518217456}


---
>[!QUOTE]  
>At the very least, functional decomposition couples services to the requirements because the services are a reflection of the requirements. Any change in the required functionality imposes a change on the functional services. ([LocationÂ 675](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=675)) #âœ‚ï¸ 
{ #ref-518217457}


---
>[!QUOTE]  
>Because functional decomposition is also decomposition based on time (call A and then call B), it effectively precludes individual reuse of services. Suppose another system also needs a B service (such as Billing). Built into the fabric of B is the notion that it was called after an A and before a C service (such as first Invoicing, and only then Billing against an invoice, and finally Shipping). ([LocationÂ 684](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=684)) #âœ‚ï¸ 
{ #ref-518217458}


---
>[!QUOTE]  
>One way of performing functional decomposition is to have as many services as there are variations of the functionalities. This decomposition leads to an explosion of services, since a decently sized system may have hundreds of functionalities. Not only do you have too many services, but these services often duplicate a lot of the common functionality, each customized to their case. ([LocationÂ 702](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=702)) #âœ‚ï¸ 
{ #ref-518217459}


---
>[!QUOTE]  
>Another functional decomposition approach is to lump all possible ways of performing the operations into mega services. This leads to bloating in the size of the services, making them overly complex and impossible to maintain. ([LocationÂ 706](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=706)) #âœ‚ï¸ 
{ #ref-518217460}


---
>[!QUOTE]  
>Functional decomposition, therefore, tends to make services either too big and too few or too small and too many. You often see both afflictions side by side in the same system. ([LocationÂ 709](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=709)) #âœ‚ï¸ 
{ #ref-518217461}


---
>[!QUOTE]  
>Functional decomposition often leads to flattening of the system hierarchy. Since each service or building block is devoted to a specific functionality, someone must combine these discrete functionalities into a required behavior. That someone is often the client. ([LocationÂ 714](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=714)) #âœ‚ï¸ 
{ #ref-518217462}


---
>[!QUOTE]  
>The hallmark of a bad design is when any change to the system affects the client. Ideally, the client and services should be able to evolve independently. ([LocationÂ 732](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=732)) #âœ‚ï¸ 
{ #ref-518217463}


---
>[!QUOTE]  
>Yet, when designed as in Figure 2-1, you are forced to pollute the client with the business logic of sequencing, ordering, error compensation, and duration of the calls. ([LocationÂ 734](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=734)) #âœ‚ï¸ 
{ #ref-518217464}


---
>[!QUOTE]  
>Cyclomatic complexity measures the number of independent paths through the code of a class or service. The more the internals are convoluted and coupled, the higher the cyclomatic complexity score. ([LocationÂ 747](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=747)) #âœ‚ï¸ 
{ #ref-518217465}


---
>[!QUOTE]  
>Another problem with the decomposition of Figure 2-1 is that it requires multiple points of entry to the system. The client (or clients) needs to enter the system in three places: once for the A, then for the B, then for the C service. This means there are multiple places to worry about authentication, authorization, scalability, instance management, transaction propagation, identities, hosting, and so on. ([LocationÂ 761](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=761)) #âœ‚ï¸ 
{ #ref-518217466}


---
>[!QUOTE]  
>The advantage of doing so is that you get to keep the clients simple and even asynchronous: the clients issue the call to the A service. The A service then calls B, and B calls C. The problem now is that the functional services are coupled to each other and to the order of the functional calls. For example, you can call the Billing service only after the Invoicing service but before the Shipping service. In the case of Figure 2-3, built into the A service is the knowledge that it needs to call the B service. The B service can be called only after the A service and before the C service. A change in the required ordering of the calls is likely to affect all services up and down the chain because their implementation will have to change to reflect the new required order. ([LocationÂ 773](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=773)) #âœ‚ï¸ 
{ #ref-518217467}


---
>[!QUOTE]  
>Chaining functionality leads to bloated services. ([LocationÂ 801](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=801)) #âœ‚ï¸ 
{ #ref-518217468}


---
>[!QUOTE]  
>Functional decomposition holds an almost irresistible allure. It looks like a simple and clear way of designing the system, requiring you to simply list the required functionalities and then create a component in your architecture for each. Functional decomposition (and its kin, the domain decomposition discussed later) is how most systems are designed. ([LocationÂ 842](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=842)) #âœ‚ï¸ 
{ #ref-518217469}


---
>[!QUOTE]  
>At all costs, you must resist the temptations of functional decomposition. ([LocationÂ 847](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=847)) #âœ‚ï¸ 
{ #ref-518217470}


---
>[!QUOTE]  
>Consider building a house functionally, as if it were a software system. You start by listing all the required functionalities of the house, such as cooking, playing, resting, sleeping, and so on. You then create an actual component in the architecture for each functionality, ([LocationÂ 875](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=875)) #âœ‚ï¸ 
{ #ref-518217471}


---
>[!QUOTE]  
>The derision in these pages does not mean functional decomposition is a bad idea. Functional decomposition has a placeâ€”it is a decent requirements discovery technique. ([LocationÂ 893](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=893)) #âœ‚ï¸ 
{ #ref-518217472}


---
>[!QUOTE]  
>domain decomposition: decomposing a system into building blocks based on the business domains, such as sales, engineering, accounting, and shipping. Sadly, domain decomposition such as Figure 2-7 shows is even worse than the functional decomposition of Figure 2-6 ([LocationÂ 901](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=901)) #âœ‚ï¸ 
{ #ref-518217473}


---
>[!QUOTE]  
>The problem is that you can never deploy a single feature in isolation. There is no business value in Billing independent from Invoicing and Shipping. ([LocationÂ 944](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=944)) #âœ‚ï¸ 
{ #ref-518217474}


---
>[!QUOTE]  
>A crucial flaw of both functional and domain decomposition has to do with testing. With such designs, the level of coupling and complexity is so high that the only kind of testing developers can do is unit testing. However, that does not make unit testing important, and it is merely another example of the streetlight effect1 (i.e., searching for something where it is easiest to look). 1. https://en.wikipedia.org/wiki/Streetlight_effect ([LocationÂ 968](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=968)) #âœ‚ï¸ 
{ #ref-518217475}


---
>[!QUOTE]  
>Contrary to intuition, software requires design even more than physical systems do. The reason is simple: complexity. The complexity of physical systems such as typical houses is capped by physical constraints. ([LocationÂ 996](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=996)) #âœ‚ï¸ 
{ #ref-518217476}


---
>[!QUOTE]  
>Without such natural physical restraints, complexity in software systems can get quickly out of control. The only way to rein in that complexity is to apply good engineering methods, of which design and process are paramount. ([LocationÂ 1001](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1001)) #âœ‚ï¸ 
{ #ref-518217477}


---
##### Volatility-Based Decomposition
>[!QUOTE]  
>Decompose based on volatility. Volatility-based decomposition identifies areas of potential change and encapsulates those into services or system building blocks. You then implement the required behavior as the interaction between the encapsulated areas of volatility. ([LocationÂ 1091](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1091)) #âœ‚ï¸ 
{ #ref-518217478}


---
>[!QUOTE]  
>Functional decomposition therefore tends to maximize the effect of the change. Since most software systems are designed functionally, change is often painful and expensive, and the system is likely to resonate with the change. ([LocationÂ 1103](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1103)) #âœ‚ï¸ 
{ #ref-518217479}


---
>[!QUOTE]  
>Accommodating change is the real reason you must avoid functional decomposition. ([LocationÂ 1105](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1105)) #âœ‚ï¸ 
{ #ref-518217480}


---
>[!QUOTE]  
>A functional decomposition of your own body would have components for every task you are required to do, from driving to programming to presenting, yet your body does not have any such components. ([LocationÂ 1139](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1139)) #âœ‚ï¸ 
{ #ref-518217481}


---
>[!QUOTE]  
>Volatility-based decomposition lends well to regression testing. The reduction in the number of components, the reduction in the size of components, and the simplification of the interactions between components all drastically reduce the complexity of the system. This makes it feasible to write regression testing that tests the system end to end, tests each subsystem individually, and eventually tests independent components. ([LocationÂ 1157](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1157)) #âœ‚ï¸ 
{ #ref-518217482}


---
>[!QUOTE]  
>In 1972, David Parnas (an early pioneer of software engineering) published a seminal paper called â€œOn the Criteria to Be Used in Decomposing Systems into Modules.â€a This short, five-page paper contains most elements of modern software engineering, including encapsulation, information hiding, cohesion, modules, and loose coupling. ([LocationÂ 1165](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1165)) #âœ‚ï¸ 
{ #ref-518217483}


---
>[!QUOTE]  
>It is the 2% problem again: it is not worth your while learning how to fix that sink if it is clogged less than 2% of the time. The moral is that when you spend 2% of your time on any complex task, you will never be any good at it. ([LocationÂ 1199](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1199)) #âœ‚ï¸ 
{ #ref-518217484}


---
>[!QUOTE]  
>In 1999, David Dunning and Justin Kruger published their research2 demonstrating conclusively that people unskilled in a domain tend to look down on it, thinking it is less complex, risky, or demanding than it truly is. This cognitive bias has nothing to do with intelligence or expertise in other domains. If you are unskilled in something, you never assume it is more complex than it is, you assume it is less! 2. Justin Kruger and David Dunning, â€œUnskilled and Unaware of It: How Difficulties in Recognizing Oneâ€™s Own Incompetence Lead to Inflated Self-Assessments,â€ Journal of Personality and Social Psychology 77, no. 6 (1999): 1121â€“1134. ([LocationÂ 1215](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1215)) #âœ‚ï¸ 
{ #ref-518217485}


---
##### Identifying Volatility
>[!QUOTE]  
>Not everything that is variable is also volatile. ([LocationÂ 1237](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1237)) #âœ‚ï¸ 
{ #ref-518217486}


---
>[!QUOTE]  
>You resort to encapsulating a volatility at the system design level only when it is open-ended and, unless encapsulated in a component of the architecture, would be very expensive to contain. ([LocationÂ 1237](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1237)) #âœ‚ï¸ 
{ #ref-518217487}


---
>[!QUOTE]  
>Variability, on the other hand, describes those aspects that you can easily handle in your code using conditional logic. ([LocationÂ 1238](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1238)) #âœ‚ï¸ 
{ #ref-518217488}


---
>[!QUOTE]  
>When searching for volatility, you should be on the lookout for the kind of changes or risks that would have ripple effects across the system. ([LocationÂ 1239](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1239)) #âœ‚ï¸ 
{ #ref-518217489}


---
>[!QUOTE]  
>There is a simple technique I call axes of volatility. This technique examines the ways the system is used by customers. ([LocationÂ 1243](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1243)) #âœ‚ï¸ 
{ #ref-518217490}


---
>[!QUOTE]  
>Customer in this context refers to a consumer of the system, which could be a single user or a whole other business entity. ([LocationÂ 1244](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1244)) #âœ‚ï¸ 
{ #ref-518217491}


---
>[!QUOTE]  
>In any business, there are only two ways your system could face change: the first axis is at the same customer over time. Even if presently the system is perfectly aligned with a particular customerâ€™s needs, over time, that customerâ€™s business context will change. ([LocationÂ 1245](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1245)) #âœ‚ï¸ 
{ #ref-518217492}


---
>[!QUOTE]  
>The tendency of a solution to change the requirements against which it was developed was first observed by the 19th-century English economist William Jevons with regard to coal production, and it is referred to since as the Jevons paradox. Other manifestations are the increase in paper consumption with the digital office and the worsening traffic congestion following an increase in road capacity. ([LocationÂ 1250](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1250)) #âœ‚ï¸ 
{ #ref-518217493}


---
>[!QUOTE]  
>The second way change could come is at the same time across customers. ([LocationÂ 1253](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1253)) #âœ‚ï¸ 
{ #ref-518217494}


---
>[!QUOTE]  
>When searching for potential volatility in interviews, you will find it very helpful to phrase the questions in terms of the axes of volatility (same customer over time, all customers at the same point in time). ([LocationÂ 1256](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1256)) #âœ‚ï¸ 
{ #ref-518217495}


---
>[!QUOTE]  
>Almost always, the axes should be independent. Something that changes for one customer over time should not change as much across all customers at the same point in time, and vice versa. If areas of change cannot be isolated to one of the axes, it often indicates a functional decomposition in disguise. ([LocationÂ 1270](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1270)) #âœ‚ï¸ 
{ #ref-518217496}


---
>[!QUOTE]  
>Since most requirements specifications are chock-full of solutions masquerading as requirements, functional decomposition absolutely maximizes your pain. You will forever be chasing the ever-evolving solutions, never recognizing the true underlying requirements. ([LocationÂ 1325](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1325)) #âœ‚ï¸ 
{ #ref-518217497}


---
>[!QUOTE]  
>The fact that requirements specifications have all those solutions masquerading as requirements is actually a blessing in disguise because you can generalize the example of cooking in the house into a bona fide analysis technique for discovering areas of volatility. ([LocationÂ 1327](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1327)) #âœ‚ï¸ 
{ #ref-518217498}


---
>[!QUOTE]  
>Prior to decomposing a system and creating an architecture, you should simply compile a list of the candidate areas of volatility as a natural part of requirements gathering and analysis. ([LocationÂ 1333](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1333)) #âœ‚ï¸ 
{ #ref-518217499}


---
>[!QUOTE]  
>During system decomposition, you must identify both the areas of volatility to encapsulate and those not to encapsulate (e.g., the nature of the business). Sometimes, you will have initial difficulty in telling these apart. There are two simple indicators if something that could change is indeed part of the nature of the business. The first indicator is that the possible change is rare. Yes, it could happen, but the likelihood of it happening is very low. The second indicator is that any attempt to encapsulate the change can only be done poorly. No practical amount of investment in time or effort will properly encapsulate the aspect in a way of which you can be proud. ([LocationÂ 1470](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1470)) #âœ‚ï¸ 
{ #ref-518217500}


---
>[!QUOTE]  
>Another useful technique for identifying volatilities is to try to design a system for your competitor (or another division in your company). ([LocationÂ 1508](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1508)) #âœ‚ï¸ 
{ #ref-518217501}


---
>[!QUOTE]  
>Ask yourself the following question: Can Federal Express use the software system UPS is using? Can UPS use the system Federal Express wants to build? If the likely answer is no, start listing all the barriers for such a reuse or extensibility. While both companies perform in the abstract the same service, the way they conduct their business is different. ([LocationÂ 1511](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1511)) #âœ‚ï¸ 
{ #ref-518217502}


---
>[!QUOTE]  
>The opposite case is also true. If you and your competitor (and even better, all competitors) do some activity or sequence the same way, and there is no chance of your system doing it any other way, then there is no need to allocate a component in the architecture for that activity. To do so would create a functional decomposition. When you encounter something your competitors do identically, more likely than not, it represents the nature of the business, and as discussed previously, you should not encapsulate it. ([LocationÂ 1518](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1518)) #âœ‚ï¸ 
{ #ref-518217503}


---
>[!QUOTE]  
>Volatility is intimately related to longevity. The longer the company or the application has been doing something the same way, the higher the likelihood the company will keep doing it the same way. Put differently, the longer things do not change, the longer they have until they do change or are replaced. You must put forward a design that accommodates such changes, even if at first glance such changes are independent of the current requirements. ([LocationÂ 1523](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1523)) #âœ‚ï¸ 
{ #ref-518217504}


---
>[!QUOTE]  
>You can even guesstimate how long it will be until such a change is likely to take place using a simple heuristic: the ability of the organization (or the customer or the market) to instigate or absorb a change is more or less constant because it is tied to the nature of the business. ([LocationÂ 1526](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1526)) #âœ‚ï¸ 
{ #ref-518217505}


---
#### 3. Structure
##### Use Cases and Requirements
>[!QUOTE]  
>Before diving into architecture, consider requirements. Most projects, if they even bother to capture the requirements, use functional requirements. Functional requirements simply state the required functionality, such as â€œThe system should do A.â€ This is actually a poor way of specifying requirements, because it leaves the systemâ€™s implementation of the A functionality open for interpretation. ([LocationÂ 1578](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1578)) #âœ‚ï¸ 
{ #ref-518217506}


---
>[!QUOTE]  
>Requirements should capture the required behavior rather than the required functionality. You should specify how the system is required to operate as opposed to what it should do, which is arguably the essence of requirements gathering. ([LocationÂ 1585](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1585)) #âœ‚ï¸ 
{ #ref-518217507}


---
>[!QUOTE]  
>A use case is an expression of required behaviorâ€”that is, how the system is required to go about accomplishing some work and adding value to the business. As such, a use case is a particular sequence of activities in the system. Use cases tend to be verbose and descriptive. They can describe end-user interactions with the system, or the systemâ€™s interactions with other systems, or back-end processing. ([LocationÂ 1589](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1589)) #âœ‚ï¸ 
{ #ref-518217508}


---
>[!QUOTE]  
>The best way of capturing a use case is graphically, with a diagram (Figure 3-1). Humans perform image processing astonishingly quickly, because almost half the human brain is a massive video processing unit. ([LocationÂ 1599](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1599)) #âœ‚ï¸ 
{ #ref-518217509}


---
>[!QUOTE]  
>My rule of thumb: The presence of a nested â€œifâ€ tells you that you should draw the use case. ([LocationÂ 1605](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1605)) #âœ‚ï¸ 
{ #ref-518217510}


---
>[!QUOTE]  
>The Method prefers activity diagrams1 for graphical representation of use cases, primarily because activity diagrams can capture time-critical aspects of behavior, something that flowcharts and other diagrams are incapable of doing. ([LocationÂ 1611](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1611)) #âœ‚ï¸ 
{ #ref-518217511}


---
>[!QUOTE]  
>Software systems are typically designed in layers, and The Method relies heavily on layers. Layers allow you to layer encapsulation. Each layer encapsulates its own volatilities from the layers above and the volatilities in the layers below. ([LocationÂ 1626](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1626)) #âœ‚ï¸ 
{ #ref-518217512}


---
##### Layered Approach
>[!QUOTE]  
>Even simple systems should be designed in layers to gain the benefit of encapsulation. In theory, the more layers, the better the encapsulation. Practical systems will have only a handful of layers, terminating with a layer of actual physical resources such as a data storage or a message queue. ([LocationÂ 1631](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1631)) #âœ‚ï¸ 
{ #ref-518217513}


---
>[!QUOTE]  
>The preferred way of crossing layers is by calling services. While you certainly can benefit from the structure of The Method and volatility-based decomposition even with regular classes, relying on services provides distinct advantages. Which technology and platform you use to implement your services is a secondary concern. ([LocationÂ 1634](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1634)) #âœ‚ï¸ 
{ #ref-518217514}


---
>[!QUOTE]  
>When you do use services (as long as the technology you chose allows), you immediately gain the following benefits: Scalability. ([LocationÂ 1636](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1636)) #âœ‚ï¸ 
{ #ref-518217515}


---
>[!QUOTE]  
>Security. All service-oriented platforms treat security as a first-class aspect. ([LocationÂ 1640](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1640)) #âœ‚ï¸ 
{ #ref-518217516}


---
>[!QUOTE]  
>Throughput and availability. Services can accept calls over queues, allowing you to handle a very large volume of messages by simply queuing up the excess load. ([LocationÂ 1642](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1642)) #âœ‚ï¸ 
{ #ref-518217517}


---
>[!QUOTE]  
>Responsiveness. Services can throttle the calls into a buffer to avoid maxing out the system. ([LocationÂ 1644](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1644)) #âœ‚ï¸ 
{ #ref-518217518}


---
>[!QUOTE]  
>Reliability. Clients and services can use some reliable messaging protocol to guarantee delivery, handle network connectivity issues, and even order the calls. ([LocationÂ 1645](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1645)) #âœ‚ï¸ 
{ #ref-518217519}


---
>[!QUOTE]  
>Consistency. The services can all participate in the same unit of work, either in a transaction (when supported by the infrastructure) or in a coordinated business transaction that is eventually consistent. ([LocationÂ 1646](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1646)) #âœ‚ï¸ 
{ #ref-518217520}


---
>[!QUOTE]  
>Synchronization. The calls to the service can be automatically synchronized even if the clients use multiple concurrent threads. ([LocationÂ 1649](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1649)) #âœ‚ï¸ 
{ #ref-518217521}


---
>[!QUOTE]  
>The Method calls for four layers in the system architecture. These layers conform to some classic software engineering practices. ([LocationÂ 1651](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1651)) #âœ‚ï¸ 
{ #ref-518217522}


---
##### Typical Layers
>[!QUOTE]  
>The top layer in architecture is the client layer, also known as the presentation layer. I find the term â€œpresentationâ€ to be somewhat misleading. â€œPresentationâ€ implies some information is being presented to human users, as if that is all that is expected from the top layer. The elements in the client layer may very well be end-user applications, but they can also be other systems interacting with your system. ([LocationÂ 1656](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1656)) #âœ‚ï¸ 
{ #ref-518217523}


---
>[!QUOTE]  
>The client layer also encapsulates the potential volatility in Clients. Your system now and in the future across the axes of volatility may have different Clients such as desktop applications, web portals, mobile apps, holograms and augmented reality, APIs, administration applications, and so on. ([LocationÂ 1667](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1667)) #âœ‚ï¸ 
{ #ref-518217524}


---
>[!QUOTE]  
>The business logic layer encapsulates the volatility in the systemâ€™s business logic. This layer implements the systemâ€™s required behavior, which, as mentioned previously, is best expressed in use cases. ([LocationÂ 1673](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1673)) #âœ‚ï¸ 
{ #ref-518217525}


---
>[!QUOTE]  
>Use cases, however, are volatile, across both customers and time. Since a use case contains a sequence of activities in the system, a particular use case can change in only two ways: Either the sequence itself changes or the activities within the use case change. ([LocationÂ 1675](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1675)) #âœ‚ï¸ 
{ #ref-518217526}


---
>[!QUOTE]  
>Both the sequence and the activities are volatile, and in The Method these volatilities are encapsulated in specific components called Managers and Engines. Manager components encapsulate the volatility in the sequence, whereas Engine components encapsulate the volatility in the activity. ([LocationÂ 1687](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1687)) #âœ‚ï¸ 
{ #ref-518217527}


---
>[!QUOTE]  
>Since use cases are often related, Managers tend to encapsulate a family of logically related use cases, such as those in a particular subsystem. ([LocationÂ 1693](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1693)) #âœ‚ï¸ 
{ #ref-518217528}


---
>[!QUOTE]  
>Since you can have great volatility in the sequence without any volatility in the activities of the sequence (see Figure 3-5), Managers may use zero or more Engines. Engines may be shared between Managers because you could perform an activity in one use case on behalf of one Manager and then perform the same activity for another Manager in a separate use case. ([LocationÂ 1698](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1698)) #âœ‚ï¸ 
{ #ref-518217529}


---
>[!QUOTE]  
>You should design Engines with reuse in mind. However, if two Managers use two different Engines to perform the same activity, you either have functional decomposition on your hands or you have missed some activity volatility. ([LocationÂ 1701](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1701)) #âœ‚ï¸ 
{ #ref-518217530}


---
>[!QUOTE]  
>The aptly named resource access layer encapsulates the volatility in accessing a resource, and the components in this layer are called ResourceAccess. ([LocationÂ 1704](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1704)) #âœ‚ï¸ 
{ #ref-518217531}


---
>[!QUOTE]  
>While the motivation behind the resource access layer is readily evident and many systems incorporate some form of an access layer, most such layers end up exposing the underlying volatility by creating a ResourceAccess contract that resembles I/O operations or that is CRUD-like. For example, if your ResourceAccess service contract contains operations such as Select(), Insert(), and Delete(), the underlying resource is most likely a database. If you later change the database to a distributed cloud-based hash table, that database-access-like contract will become useless, and a new contract is required. Changing the contract affects every Engine and Manager that has used the ResourceAccess component. ([LocationÂ 1710](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1710)) #âœ‚ï¸ 
{ #ref-518217532}


---
>[!QUOTE]  
>A well-designed ResourceAccess component exposes in its contract the atomic business verbs around a resource. ([LocationÂ 1721](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1721)) #âœ‚ï¸ 
{ #ref-518217533}


---
>[!QUOTE]  
>The Method refers to these indivisible activities as atomic business verbs. ([LocationÂ 1725](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1725)) #âœ‚ï¸ 
{ #ref-518217534}


---
>[!QUOTE]  
>Atomic business verbs are practically immutable because they relate strongly to the nature of the business, which, as discussed in Chapter 2, hardly ever changes. ([LocationÂ 1728](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1728)) #âœ‚ï¸ 
{ #ref-518217535}


---
>[!QUOTE]  
>ResourceAccess services can be shared between Managers and Engines. You should explicitly design ResourceAccess components with this reuse in mind. If two Managers or two Engines cannot use the same ResourceAccess service when accessing the same resource or have some need for specific access, perhaps you did not encapsulate some access volatility or did not isolate the atomic business verbs correctly. ([LocationÂ 1734](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1734)) #âœ‚ï¸ 
{ #ref-518217536}


---
>[!QUOTE]  
>The resource layer contains the actual physical Resources on which the system relies, such as a database, file system, a cache, or a message queue. In The Method, the Resource can be internal to the system or outside the system. Often, the Resource is a whole system in its own right, but to your system it appears as just a Resource. ([LocationÂ 1738](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1738)) #âœ‚ï¸ 
{ #ref-518217537}


---
##### Classification Guidelines
>[!QUOTE]  
>The Method recommends the following conventions for naming them: Names of services must be two-part compound words written in Pascal case. The suffix of the name is always the serviceâ€™s typeâ€”for example, Manager, Engine, or Access (for ResourceAccess). The prefix varies with the type of service. â€“Â Â For Managers, the prefix should be a noun associated with the encapsulated volatility in the use cases. â€“Â Â For Engines, the prefix should be a noun describing the encapsulated activity. â€“Â Â For ResourceAccess, the prefix should be a noun associated with the Resource, such as data that the service provides to the consuming use cases. Gerunds (a gerund is a noun created by tacking â€œingâ€ onto a verb) should be used as a prefix only in with Engines. The use of gerunds elsewhere in the business or access layers usually signals functional decomposition. Atomic business verbs should not be used in a prefix for a service name. These verbs should be confined to operation names in contracts interfacing with the resource access layer. ([LocationÂ 1757](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1757)) #âœ‚ï¸ 
{ #ref-518217538}


---
>[!QUOTE]  
>The layers of services and resources in the architecture loosely correspond to the four English questions of â€œwho,â€ â€œwhat,â€ â€œhow,â€ and â€œwhere.â€ â€œWhoâ€ interacts with the system is in the Clients, â€œwhatâ€ is required of the system is in Managers, â€œhowâ€ the system performs business activities is in Engines, â€œhowâ€ the system accesses Resources is in ResourceAccess, and â€œwhereâ€ the system state is in Resources (see Figure 3-7). ([LocationÂ 1778](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1778)) #âœ‚ï¸ 
{ #ref-518217539}


---
>[!QUOTE]  
>If your design contains a large number of Engines, you may have inadvertently done a functional decomposition. ([LocationÂ 1803](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1803)) #âœ‚ï¸ 
{ #ref-518217540}


---
>[!QUOTE]  
>If your system has eight Managers, then you have already failed to produce a good design: The large number of Managers strongly indicates you have done a functional or domain decomposition. ([LocationÂ 1809](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1809)) #âœ‚ï¸ 
{ #ref-518217541}


---
>[!QUOTE]  
>In a well-designed system, volatility should decrease top-down across the layers. Clients are very volatile. ([LocationÂ 1821](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1821)) #âœ‚ï¸ 
{ #ref-518217542}


---
>[!QUOTE]  
>Managers do change, but not as much as their Clients. Managers change when the use casesâ€”the required behavior of the systemâ€”change. ([LocationÂ 1824](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1824)) #âœ‚ï¸ 
{ #ref-518217543}


---
>[!QUOTE]  
>Engines are less volatile than Managers. For an Engine to change, your business must change the way it is performing some activity, which is more uncommon than changing the sequencing of activities. ([LocationÂ 1825](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1825)) #âœ‚ï¸ 
{ #ref-518217544}


---
>[!QUOTE]  
>ResourceAccess services are even less volatile than Engines. How often do you change the way you access a Resource or, for that matter, change the Resource? ([LocationÂ 1826](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1826)) #âœ‚ï¸ 
{ #ref-518217545}


---
>[!QUOTE]  
>Resources are the least volatile components, changing at a glacial pace compared with the rest of the system. ([LocationÂ 1829](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1829)) #âœ‚ï¸ 
{ #ref-518217546}


---
>[!QUOTE]  
>Reuse, unlike volatility, should increase going down the layers. ([LocationÂ 1833](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1833)) #âœ‚ï¸ 
{ #ref-518217547}


---
>[!QUOTE]  
>Clients are hardly ever reusable. A Client application is typically developed for a particular type of platform and market and cannot be reused. ([LocationÂ 1833](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1833)) #âœ‚ï¸ 
{ #ref-518217548}


---
>[!QUOTE]  
>Managers are reusable because you can use the same Manager and use cases from multiple Clients. ([LocationÂ 1835](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1835)) #âœ‚ï¸ 
{ #ref-518217549}


---
>[!QUOTE]  
>Engines are even more reusable than Managers because the same Engine could be called by multiple Managers, in different use cases, to perform the same activity. ([LocationÂ 1836](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1836)) #âœ‚ï¸ 
{ #ref-518217550}


---
>[!QUOTE]  
>ResourceAccess components are very reusable because they can be called by Engines and Managers. ([LocationÂ 1838](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1838)) #âœ‚ï¸ 
{ #ref-518217551}


---
>[!QUOTE]  
>The Resources are the most reusable element in any well-designed systems. ([LocationÂ 1838](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1838)) #âœ‚ï¸ 
{ #ref-518217552}


---
>[!QUOTE]  
>Managers can fall into one of three categories: expensive, expendable, and almost expendable. You can distinguish the category to which a Manager belongs by the way you respond when you are asked to change it. ([LocationÂ 1841](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1841)) #âœ‚ï¸ 
{ #ref-518217553}


---
>[!QUOTE]  
>If your response is to fight the change, to fear its cost, to argue against the change, and so forth, then the Manager was clearly expensive and not expendable. An expensive Manager indicates that the Manager is too big, likely due to functional decomposition. If your response to the change request is just to shrug it off, thinking little of it, the Manager is pass-through and expendable. ([LocationÂ 1843](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1843)) #âœ‚ï¸ 
{ #ref-518217554}


---
>[!QUOTE]  
>Expendable Managers are always a design flaw and a distortion of the architecture. They often exist only to satisfy the design guidelines without any real need for encapsulating use case volatility. ([LocationÂ 1846](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1846)) #âœ‚ï¸ 
{ #ref-518217555}


---
>[!QUOTE]  
>A well-designed Manager service should be almost expendable. ([LocationÂ 1851](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1851)) #âœ‚ï¸ 
{ #ref-518217556}


---
##### Subsystems and Services
>[!QUOTE]  
>The Managers, Engines, and ResourceAccess are all services on their own right. A cohesive interaction between the Manager, Engines, and ResourceAccess may constitute a single logical service to external consumers. You can view such a set of interacting services as a logical subsystem. You group these together as a vertical slice of your system (Figure 3-8), where each vertical slice implements a corresponding set of use cases. ([LocationÂ 1853](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1853)) #âœ‚ï¸ 
{ #ref-518217557}


---
>[!QUOTE]  
>Avoid over-partitioning your system into subsystems. Most systems should have only a handful of subsystems. Likewise, you should limit the number of Managers per subsystem to three. ([LocationÂ 1858](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1858)) #âœ‚ï¸ 
{ #ref-518217558}


---
>[!QUOTE]  
>Design iteratively, build incrementally. ([LocationÂ 1870](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1870)) #âœ‚ï¸ 
{ #ref-518217559}


---
>[!QUOTE]  
>There are two reasons why you can build only incrementally, and not iteratively. First, building iteratively is horrendously wasteful and difficult (turning a motorcycle into a car is much more difficult than just building a car). Second, and much more importantly, the intermediate iterations do not have any business value. If the customer wants a car to take the kids to school, what would the customer do with a motorcycle and why should the customer pay for it? ([LocationÂ 1885](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1885)) #âœ‚ï¸ 
{ #ref-518217560}


---
>[!QUOTE]  
>The vertical slices of the system also enable you to accommodate extensibility. The correct way of extending any system is not by opening it up and hammering on existing components. ([LocationÂ 1898](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1898)) #âœ‚ï¸ 
{ #ref-518217561}


---
>[!QUOTE]  
>In common usage, microservices correspond to domains or subsystemsâ€”that is, to the slices (red boxes) of Figure 3-8. There are three problems with this idea as practiced today. ([LocationÂ 1923](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1923)) #âœ‚ï¸ 
{ #ref-518217562}


---
>[!QUOTE]  
>The first problem is the implied constraint on the number of services. If smaller services are better than larger services, why stop at the subsystem level? ([LocationÂ 1925](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1925)) #âœ‚ï¸ 
{ #ref-518217563}


---
>[!QUOTE]  
>The second problem is the widespread use of functional decomposition in microservice design by the industry at large. ([LocationÂ 1932](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1932)) #âœ‚ï¸ 
{ #ref-518217564}


---
>[!QUOTE]  
>The third problem relates to communication protocols. Although the choice of communication protocols has more to do with detailed design than with architecture, the effect of the choice is worth a passing comment here. ([LocationÂ 1937](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1937)) #âœ‚ï¸ 
{ #ref-518217565}


---
>[!QUOTE]  
>As a general principle, in any well-designed system you should never use the same communication mechanism both internally and externally. ([LocationÂ 1941](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1941)) #âœ‚ï¸ 
{ #ref-518217566}


---
>[!QUOTE]  
>Any layered architecture can have one of two possible operational models: open or closed. ([LocationÂ 1959](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1959)) #âœ‚ï¸ 
{ #ref-518217567}


---
##### Open and Closed Architectures
>[!QUOTE]  
>In an open architecture, any component can call any other component regardless of the layer in which the components reside. ([LocationÂ 1962](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1962)) #âœ‚ï¸ 
{ #ref-518217568}


---
>[!QUOTE]  
>Calling sideways in this way is almost always the result of functional decomposition at the Managers level. ([LocationÂ 1981](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1981)) #âœ‚ï¸ 
{ #ref-518217569}


---
>[!QUOTE]  
>When using open architecture, there is hardly any benefit of having architectural layers in the first place. In general, in software engineering, trading encapsulation for flexibility is a bad trade. ([LocationÂ 1986](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1986)) #âœ‚ï¸ 
{ #ref-518217570}


---
>[!QUOTE]  
>In a closed architecture, you strive to maximize the benefits of the layers by disallowing calling up between layers and sideways within layers. ([LocationÂ 1988](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1988)) #âœ‚ï¸ 
{ #ref-518217571}


---
>[!QUOTE]  
>Closed architecture promotes decoupling by trading flexibility for encapsulation. In general, that is a better trade than the other way around. ([LocationÂ 1992](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1992)) #âœ‚ï¸ 
{ #ref-518217572}


---
>[!QUOTE]  
>A semi-closed/semi-open architecture allows calling more than one layer down. This, again, is a trade of encapsulation for flexibility and performance and, in general, is a trade to avoid. ([LocationÂ 1997](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1997)) #âœ‚ï¸ 
{ #ref-518217573}


---
>[!QUOTE]  
>Notably, the use of semi-closed/semi-open architecture is justified in two classic cases. This first case occurs when you design some key piece of infrastructure, and you must squeeze every ounce of performance from it. ([LocationÂ 1999](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=1999)) #âœ‚ï¸ 
{ #ref-518217574}


---
>[!QUOTE]  
>The second case occurs within a codebase that hardly ever changes. ([LocationÂ 2004](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2004)) #âœ‚ï¸ 
{ #ref-518217575}


---
>[!QUOTE]  
>In a closed architecture, Utilities pose a challenge. Consider Logging, a service used for recording run-time events. If you classify Logging as a Resource, then the ResourceAccess can use it, but the Managers cannot. If you place Logging at the same level as the Managers, only the Clients can log. The same goes for Security or Diagnosticsâ€”services that almost all other components require. In short, there is no good location for Utilities among the layers of a closed architecture. The Method places Utilities in a vertical bar on the side of the layers (see Figure 3-4). This bar cuts across all layers, allowing any component in the architecture to use any Utility. ([LocationÂ 2016](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2016)) #âœ‚ï¸ 
{ #ref-518217576}


---
>[!QUOTE]  
>To qualify as a Utility, the component must pass a simple litmus test: Can the component plausibly be used in any other system, such as a smart cappuccino machine? ([LocationÂ 2026](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2026)) #âœ‚ï¸ 
{ #ref-518217577}


---
>[!QUOTE]  
>This next guideline may be implied, but it is important enough to state explicitly. Because they are in the same layer, both Managers and Engines can call ResourceAccess services without violating the closed architecture (see Figure 3-4). Allowing Managers to call ResourceAccess is also implied from the section defining Managers and Engines. A Manager that uses no Engines must be able to access the underlying Resources. ([LocationÂ 2033](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2033)) #âœ‚ï¸ 
{ #ref-518217578}


---
>[!QUOTE]  
>Managers can directly call Engines. The separation between Managers and Engines is almost at the detailed design level. Engines are really just an expression of the Strategy design pattern6 used to implement the activities within the Managersâ€™ workflows. Therefore, Manager-to-Engine calls are not truly sideways calls, as is the case with Manager-to-Manager calls. ([LocationÂ 2038](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2038)) #âœ‚ï¸ 
{ #ref-518217579}


---
>[!QUOTE]  
>While Managers should not call directly sideways to other Managers, a Manager can queue a call to another Manager. ([LocationÂ 2046](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2046)) #âœ‚ï¸ 
{ #ref-518217580}


---
>[!QUOTE]  
>Using The Method structure, when a Manager queues a call to another Manager, the proxy is a ResourceAccess to the underlying Resource, the queue; that is, the call actually goes down, not sideways. ([LocationÂ 2051](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2051)) #âœ‚ï¸ 
{ #ref-518217581}


---
>[!QUOTE]  
>The semantic explanation involves the nature of use cases. Business systems quite commonly have one use case that triggers a latent, much-deferred execution of another use case. For example, imagine a system in which a Manager executing a use case must save some system state for analysis at the end of the month. Without interrupting its flow, the Manager could queue the analysis request to another Manager. The second Manager could dequeue at the monthâ€™s end and perform its analysis workflow. The two use cases are independent and decoupled on the timeline. ([LocationÂ 2054](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2054)) #âœ‚ï¸ 
{ #ref-518217582}


---
>[!QUOTE]  
>If you do one of the things on this list, you will likely live to regret it. Treat any violation of these rules as a red flag and investigate further to see what you are missing: ([LocationÂ 2078](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2078)) #âœ‚ï¸ 
{ #ref-518217583}


---
>[!QUOTE]  
>Another universal design rule is that all good architectures are symmetric. ([LocationÂ 2119](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2119)) #âœ‚ï¸ 
{ #ref-518217584}


---
>[!QUOTE]  
>The quest for symmetry, however, is only at the architecture level, not in detailed design. ([LocationÂ 2121](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2121)) #âœ‚ï¸ 
{ #ref-518217585}


---
>[!QUOTE]  
>The symmetry in software systems manifests in repeated call patterns across use cases. You should expect symmetry, and its absence is a cause for concern. ([LocationÂ 2124](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2124)) #âœ‚ï¸ 
{ #ref-518217586}


---
>[!QUOTE]  
>For example, suppose a Manager implements four use cases, three of which publish an event with the Pub/Sub service and the fourth of which does not. That break of symmetry is a design smell. Why is the fourth case different? What are you missing or overdoing? Is that Manager a real Manager, or is it a functionally decomposed component without volatility? Symmetry can also be broken by the presence of something, not just by its absence. ([LocationÂ 2125](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2125)) #âœ‚ï¸ 
{ #ref-518217587}


---
#### 4. Composition
>[!QUOTE]  
>But how do you know the composition of these components at run-time adequately satisfies all the requirements? ([LocationÂ 2135](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2135)) #âœ‚ï¸ 
{ #ref-518217588}


---
>[!QUOTE]  
>Design validation and composition, as you will see, are intimately related. ([LocationÂ 2137](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2137)) #âœ‚ï¸ 
{ #ref-518217589}


---
##### Requirements and Changes
>[!QUOTE]  
>Never design against the requirements. ([LocationÂ 2157](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2157)) #âœ‚ï¸ 
{ #ref-518217590}


---
>[!QUOTE]  
>As discussed in Chapter 3, the correct way of capturing the requirements is in the form of use cases: the required set of behaviors of the system. ([LocationÂ 2166](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2166)) #âœ‚ï¸ 
{ #ref-518217591}


---
##### Composable Design
>[!QUOTE]  
>The core use cases represent the essence of the business of the system. As discussed in Chapter 2, the nature of the business hardly ever changes, and the same goes for the core use cases. ([LocationÂ 2187](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2187)) #âœ‚ï¸ 
{ #ref-518217592}


---
>[!QUOTE]  
>Most systems have as few as two or three core use cases, and the number seldom exceeds six. ([LocationÂ 2193](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2193)) #âœ‚ï¸ 
{ #ref-518217593}


---
>[!QUOTE]  
>A core use case will almost always be some kind of an abstraction of other use cases, and it may even require a new term or name to differentiate it from the rest. ([LocationÂ 2199](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2199)) #âœ‚ï¸ 
{ #ref-518217594}


---
>[!QUOTE]  
>The whole point of requirements analysis is to recognize the core use cases (and the areas of volatility). ([LocationÂ 2202](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2202)) #âœ‚ï¸ 
{ #ref-518217595}


---
>[!QUOTE]  
>Your mission as an architect is to identify the smallest set of components that you can put together to satisfy all the core use cases. ([LocationÂ 2205](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2205)) #âœ‚ï¸ 
{ #ref-518217596}


---
>[!QUOTE]  
>I call this approach composable design. A composable design does not aim to satisfy any use case in particular. You do not target any use case in particular not just because the use cases you were given were incomplete, faulty, and full of holes and contradictions, but because they will change. ([LocationÂ 2214](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2214)) #âœ‚ï¸ 
{ #ref-518217597}


---
>[!QUOTE]  
>Since the goal of any system is to satisfy the requirements, composable design enables something else: design validation. Once you can produce an interaction between your services for each core use case, you have produced a valid design. ([LocationÂ 2222](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2222)) #âœ‚ï¸ 
{ #ref-518217598}


---
>[!QUOTE]  
>Figure 4-1 is, in The Methodâ€™s parlance, a call chain diagram. ([LocationÂ 2230](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2230)) #âœ‚ï¸ 
{ #ref-518217599}


---
>[!QUOTE]  
>A call chain demonstrates the interaction between components required to satisfy a particular use case. You can literally superimpose the call chain onto the layered architecture diagram. ([LocationÂ 2233](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2233)) #âœ‚ï¸ 
{ #ref-518217600}


---
>[!QUOTE]  
>The components in the diagram are connected by arrows indicating the direction and type of the call between componentsâ€”a solid black arrow for synchronous (request/response) calls, and a dashed gray arrow for a queued call. ([LocationÂ 2234](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2234)) #âœ‚ï¸ 
{ #ref-518217601}


---
>[!QUOTE]  
>A sequence diagram in The Methodâ€™s parlance is similar to a UML sequence diagram.1 However, it includes notational differences to assure common meanings between diagram types. ([LocationÂ 2242](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2242)) #âœ‚ï¸ 
{ #ref-518217602}


---
>[!QUOTE]  
>Remember: Your mission as the architect is to identify not just a set of components that you can put together to satisfy all the core use case, but the smallest set of components. ([LocationÂ 2258](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2258)) #âœ‚ï¸ 
{ #ref-518217603}


---
>[!QUOTE]  
>The smallest set of services required in a typical software system contains 10 services in order of magnitude (e.g., sets of both 12 and 20 are on the order of 10). This particular order of magnitude is another universal design concept. ([LocationÂ 2270](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2270)) #âœ‚ï¸ 
{ #ref-518217604}


---
>[!QUOTE]  
>Using The Method, even in a large system you are commonly looking at two to five Managers, two to three Engines, three to eight ResourceAccess and Resources, and a half-dozen Utilities. ([LocationÂ 2276](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2276)) #âœ‚ï¸ 
{ #ref-518217605}


---
>[!QUOTE]  
>You may spend weeks or months trying to identify the core use cases and the areas of volatility. However, that is not designâ€”that is requirements gathering and requirements analysis, which may be very time-consuming indeed. ([LocationÂ 2286](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2286)) #âœ‚ï¸ 
{ #ref-518217606}


---
##### There Is No Feature
>[!QUOTE]  
>Features are always and everywhere aspects of integration, not implementation. ([LocationÂ 2293](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2293)) #âœ‚ï¸ 
{ #ref-518217607}


---
#### 5. System Design Example
##### System Overview
##### The Anti-Design Effort
##### Business Alignment
>[!QUOTE]  
>The first order of business is to get all stakeholders to agree on a common vision. The vision must drive everything, from architecture to commitments. Everything that you do later has to serve that vision and be justified by it. Of course, this cuts both waysâ€”which is why it is a good idea to start with the vision. If something does not serve the vision, then it often has to do with politics and other secondary or tertiary concerns. This provides you with an excellent way of repelling irrelevant demands that do not support the agreed-upon vision. ([LocationÂ 2556](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2556)) #âœ‚ï¸ 
{ #ref-525147127}


---
>[!QUOTE]  
>A platform for building applications to support the TradeMe marketplace. ([LocationÂ 2561](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2561)) #âœ‚ï¸ #disagree 
{ #ref-525147128}


---
>[!QUOTE]  
>Vision â†’ Objectives â†’ Mission Statement â†’ Architecture ([LocationÂ 2593](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2593)) #âœ‚ï¸ 
{ #ref-525147129}


---
>[!QUOTE]  
>This is a reversal of the typical dynamics, in which the architect pleads with management to avoid functional decomposition. It is a lot easier to drive the correct architecture through the business by aligning the architecture with the businessâ€™s vision, its objectives, and the mission statement. ([LocationÂ 2595](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2595)) #âœ‚ï¸ 
{ #ref-525147130}


---
##### The Architecture
>[!QUOTE]  
>Before you dive into the act of system design, ensure everyone is on the same page by compiling a short glossary of domain terminology. ([LocationÂ 2602](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2602)) #âœ‚ï¸ 
{ #ref-525147131}


---
>[!QUOTE]  
>A good way of starting a glossary is to answer the four classic questions of â€œwho,â€ â€œwhat,â€ â€œhow,â€ and â€œwhere.â€ You answer the questions by examining the system overview, the use cases, and customer interview notes, if you have any. ([LocationÂ 2604](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2604)) #âœ‚ï¸ 
{ #ref-525147132}


---
>[!QUOTE]  
>For TradeMe, the answers to the four questions were as follows: ([LocationÂ 2606](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2606)) #âœ‚ï¸ 
{ #ref-525147133}

>>[!NOTE]  
>>.?

---
>[!QUOTE]  
>This does not preclude having additional subsystems or imply that these will necessarily be all the subsystems neededâ€”you always decompose based on volatility, and if a â€œwhatâ€ is not volatile, then it will not merit a component in the architecture. ([LocationÂ 2619](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2619)) #âœ‚ï¸ 
{ #ref-525147134}


---
>[!QUOTE]  
>There is nothing wrong with suggesting certain areas of volatility, and then examining the resultant architecture. If the result produces a spiderweb of interactions or is asymmetric, then the design is unlikely to be good. ([LocationÂ 2641](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2641)) #âœ‚ï¸ 
{ #ref-525147135}


---
>[!QUOTE]  
>The main reason for choosing a message bus is because it supports the most important operational concept of TradeMe: the Message Is the Application design pattern. When using this design pattern, the â€œapplicationâ€ is nowhere to be found. There is no collection of components or services that you can point to and identify as the application. Instead, the system comprises a loose collection of services that post and receive messages to one another (over a message bus, although that is secondary consideration). These messages are related to each other. ([LocationÂ 2777](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2777)) #âœ‚ï¸ 
{ #ref-535416286}


---
>[!QUOTE]  
>The use of granular services integrated over a message bus with the Message Is the Application design pattern is one of the best ways of preparing the system for the future. By â€œpreparing the system for the future,â€ I specifically refer to the next epoch in software engineering, the use of the actor model. ([LocationÂ 2796](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2796)) #âœ‚ï¸ 
{ #ref-535416287}


---
>[!QUOTE]  
>For more on the actor model, see Juval Lowy, Actors: The Past and Future of Software Engineering (YouTube/IDesignIncTV, 2017). ([LocationÂ 2809](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2809)) #âœ‚ï¸ 
{ #ref-535416288}


---
>[!QUOTE]  
>In many cases, a simpler design in which the Clients just queue up calls to the Managers would be a better fit for the development team. Always calibrate the architecture to the capability and maturity of the developers and management. After all, it is a lot easier to morph the architecture than it is to bend the organization. Once the organizational capabilities have matured, you can incorporate a full Message Is the Application pattern. ([LocationÂ 2815](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2815)) #âœ‚ï¸ 
{ #ref-535416289}


---
>[!QUOTE]  
>A workflow Manager is a service that enables you to create, store, retrieve, and execute workflows. In theory, it is just another Manager. In practice, however, such Managers almost always utilize some sort of third-party workflow execution tool and workflow storage. For each Client call, the workflow Manager loads not just the correct workflow type but also a specific instance of it, with a particular state and context; executes the workflow; and persists it back to the workflow store. ([LocationÂ 2824](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=2824)) #âœ‚ï¸ 
{ #ref-535416290}


---
##### Design Validation
##### Whatâ€™s Next?
### Part II: Project Design
#### 6. Motivation
##### Why Project Design?
>[!QUOTE]  
>The project needs can be classified into five levels: physical, safety, repeatability, engineering, and technology. ([LocationÂ 3065](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3065)) #âœ‚ï¸ 
{ #ref-535416291}


---
>[!QUOTE]  
>Physical. This is the lowest level in the project pyramid of needs, dealing with physical survival. Much as a person must have air, food, water, clothing, and shelter, a project must have a workplace (even a virtual one) and a viable business model. ([LocationÂ 3066](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3066)) #âœ‚ï¸ 
{ #ref-535416292}


---
>[!QUOTE]  
>Safety. Once the physical needs are satisfied, the project must have adequate funding (often in the form of allocated resources) and enough time to complete the work. ([LocationÂ 3070](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3070)) #âœ‚ï¸ 
{ #ref-535416293}


---
>[!QUOTE]  
>Repeatability. Project repeatability describes the development organizationâ€™s ability to deliver successfully time and again, and is the foundation for control and execution. It assures that if you plan for and commit to a certain schedule and cost, you will deliver on those commitments. ([LocationÂ 3074](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3074)) #âœ‚ï¸ 
{ #ref-535416294}


---
>[!QUOTE]  
>Engineering. Once the repeatability of the project effort is secured, the software project can, for the first time, turn its attention to the enticing aspects of software engineering. This includes architecture and detail design, quality assurance activities such as root cause analysis and correction (on a systemic level), and preventive work using hardened operating procedures. ([LocationÂ 3078](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3078)) #âœ‚ï¸ 
{ #ref-535416295}


---
>[!QUOTE]  
>Technology. At this level are development technology, tools, methodology, operating systems, and related hard-core technical aspects. ([LocationÂ 3082](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3082)) #âœ‚ï¸ 
{ #ref-535416296}


---
#### 7. Project Design Overview
##### Defining Success
>[!QUOTE]  
>Part 1 of this book stated a universal design rule: Features are always and everywhere aspects of integration, not implementation. As such, there are no features in any of the early services. At some point you will have integrated enough to start seeing features. I call that point the system. ([LocationÂ 3121](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3121)) #âœ‚ï¸ 
{ #ref-535416297}


---
>[!QUOTE]  
>Never base progress reports on features. Always base progress reports on integration. ([LocationÂ 3137](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3137)) #âœ‚ï¸ 
{ #ref-535416298}


---
##### Project Initial Staffing
>[!QUOTE]  
>A single architect is absolutely crucial for design integrity. You can extend this observation to the general rule that the only way to allow for design integrity is to have a single architect own the design. The opposite is also true: If no single person owns the design and can visualize it cover-to-cover, the system will not have design integrity. ([LocationÂ 3168](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3168)) #âœ‚ï¸ 
{ #ref-535416299}


---
>[!QUOTE]  
>As vital as the architect is to the project, the architect cannot work in isolation. On day 1, the project must have a core team in place. The core team consists of three roles: project manager, product manager, and architect. ([LocationÂ 3191](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3191)) #âœ‚ï¸ 
{ #ref-535416300}


---
>[!QUOTE]  
>The project manager. The job of the project manager is to shield the team from the organization. Most organizations, even small ones, create too much noise. If that noise makes its way into the development team, it can paralyze the team. A good project manager is like a firewall, blocking the noise, allowing only sanctioned communication through. ([LocationÂ 3195](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3195)) #âœ‚ï¸ 
{ #ref-535416301}


---
>[!QUOTE]  
>The product manager. The product manager should encapsulate the customers. Customers are also a constant source of noise. The product manager acts as a proxy for the customers. For example, when the architect needs to clarify the required behaviors, the architect should not chase customers; instead, the product manager should provide the answers. ([LocationÂ 3201](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3201)) #âœ‚ï¸ 
{ #ref-535416302}


---
>[!QUOTE]  
>The architect. The architect is the technical manager, acting as the design lead, the process lead, and the technical lead of the project. The architect not only designs the system, but also sees it through development. ([LocationÂ 3205](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3205)) #âœ‚ï¸ 
{ #ref-535416303}


---
>[!QUOTE]  
>The core team designs the project in the fuzzy front end leading to development. The fuzzy front end is a general term1 in all technical projects referring to the very start of the project. The front end commences when someone has an idea about the project, and it concludes when developers start construction. ([LocationÂ 3225](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3225)) #âœ‚ï¸ 
{ #ref-535416304}


---
##### Educated Decisions
>[!QUOTE]  
>The result of project design is a set of plans, not a single plan. ([LocationÂ 3255](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3255)) #âœ‚ï¸ 
{ #ref-535416305}


---
>[!QUOTE]  
>Officially, the name of the meeting should be the Software Development Plan Review, or SDP review. It makes no difference if your process does not have an SDP review point: Just call a meeting (no manager can refuse a meeting request whose subject line is â€œSoftware Development Plan Reviewâ€). Once the desired option is identified, management must literally sign off on the SDP document. This document now becomes your projectâ€™s life insurance policy because, as long as you do not deviate from the planâ€™s parameters, there is no reason to cancel your project. This does require proper tracking (as described in Appendix A) and project management. ([LocationÂ 3269](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3269)) #âœ‚ï¸ 
{ #ref-535416306}


---
##### Services and Developers
>[!QUOTE]  
>For now, recognize that you should always assign services to developers in a 1:1 ratio. The 1:1 ratio does not mean that a developer works on only one service, but rather that if you do a cross-section of the team at any moment in time, you will see a developer working on one and only one service. ([LocationÂ 3284](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3284)) #âœ‚ï¸ 
{ #ref-535416307}


---
>[!QUOTE]  
>Any other way of assigning services to developers will result in failure. Examples of the poor assignment options include: Multiple developers per service. The motivation for assigning two (or more) developers to one service is not a surplus of developers, but rather the desire to complete the work sooner. However, two people cannot really work on the same thing at the same time, so some subscheme must be used: ([LocationÂ 3288](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3288)) #âœ‚ï¸ 
{ #ref-535416308}


---
>[!QUOTE]  
>Multiple services per developer. The option of assigning two (or more) services to a single developer is just as bad. Suppose two services, A and B, each estimated as a month of work, are assigned to a single developer, with the developer expected to finish both after a single month. Since the sum of work is two months, not only will the services be incomplete after one month, but finishing them will take much longer. While the developer is working on the A service, the developer is not working on the B service, causing the developers dependent on the B service to demand that the developer work on the B service. ([LocationÂ 3302](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3302)) #âœ‚ï¸ 
{ #ref-535416309}


---
>[!QUOTE]  
>When assigning services (or activities such as UI development), try to maintain task continuity, a logical continuation between tasks assigned to each person. Often, such task assignments follow the service dependency graph. If service A depends on service B, then assign A to the developer of B. One advantage is that the A developer who is already familiar with B needs less ramp-up time. ([LocationÂ 3353](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3353)) #âœ‚ï¸ 
{ #ref-537090516}


---
##### Effort Estimations
>[!QUOTE]  
>Effort estimation is how you try to answer the question of how long something will take. There are two types of estimations: individual activity estimation (estimating the effort for an activity assigned to a resource) and overall project estimation. The two types of estimations are unrelated, because the overall duration of the project is not the sum of effort across all activities divided by number of resources. ([LocationÂ 3366](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3366)) #âœ‚ï¸ 
{ #ref-537090517}


---
>[!QUOTE]  
>Overestimation never works because of Parkinsonâ€™s law. ([LocationÂ 3382](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3382)) #âœ‚ï¸ 
{ #ref-537090518}


---
>[!QUOTE]  
>Good estimations are accurate, but not precise. For example, consider an activity that actually took 13 days and had 2 estimations: 10 days or 23.8 days. While the second estimation is far more precise, clearly the first estimation is better because it is more accurate. ([LocationÂ 3424](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3424)) #âœ‚ï¸ 
{ #ref-537090519}


---
>[!QUOTE]  
>Estimations also must match the tracking resolution. If the project manager tracks the project on a weekly basis, any estimation less than a week is pointless because it is smaller than the measurement resolution. ([LocationÂ 3429](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3429)) #âœ‚ï¸ 
{ #ref-537090520}


---
>[!QUOTE]  
>Confronted with the uncertain, take these steps: Ask first for the order of magnitude: Is the activity more like a day, a week, a month, or a year? ([LocationÂ 3444](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3444)) #âœ‚ï¸ 
{ #ref-537090521}


---
>[!QUOTE]  
>Make an explicit effort to list the areas of uncertainty in the project and focus on estimating them. Always break down large activities into smaller, more manageable activities to greatly increase the accuracy of the estimations. ([LocationÂ 3449](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3449)) #âœ‚ï¸ 
{ #ref-537090522}


---
>[!QUOTE]  
>Invest in an exploratory discovery effort that will give insight into the nature of the problem and reduce the uncertainty. ([LocationÂ 3450](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3450)) #âœ‚ï¸ 
{ #ref-537090523}


---
>[!QUOTE]  
>One estimation technique dealing specifically with high uncertainty is part of Program Evaluation and Review Technique (PERT).3 For every activity, you provide three estimations: the most optimistic, the most pessimistic, and the most likely. ([LocationÂ 3453](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3453)) #âœ‚ï¸ 
{ #ref-537090524}


---
>[!QUOTE]  
>With even a modest degree of repeatability (see Figure 6-1), it is unlikely that you could deliver the project faster or slower than similar projects in the organizationâ€™s past. The dominant factor in throughput and efficiency is the organizationâ€™s nature, its own unique fingerprint of maturity, which is something that does not change overnight or between projects. If it took your company a year to deliver a similar project in the past, then it will take it a year in the future. ([LocationÂ 3474](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3474)) #âœ‚ï¸ 
{ #ref-537090525}


---
>[!QUOTE]  
>Some tools even use Monte Carlo simulations to narrow down the range of the variables based on your project attributes or historical records. I have used such tools for decades, and they produce accurate results. ([LocationÂ 3483](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3483)) #âœ‚ï¸ 
{ #ref-537090526}


---
>[!QUOTE]  
>The broadband estimation is my adaptation of the Wideband Delphi4 estimation technique. The broadband estimation uses multiple individual estimations to identify the average of the overall project estimation, then adds a band of estimations above and below it. You use the estimations outside the band to gain insight into the nature of the project and refine the estimations, repeating this process until the band and the project estimations converge. 4. Barry Boehm, Software Engineering Economics (Prentice Hall, 1981). ([LocationÂ 3485](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3485)) #âœ‚ï¸ 
{ #ref-537090527}


---
>[!QUOTE]  
>You start the project design with the estimated duration of the individual activities in the project. Before you estimate individual activities, you must prepare a meticulous list of all activities in the project, both coding and noncoding activities alike. In a way, even that list of activities is an estimation of the actual set of activities, so the same rationale about reducing uncertainties holds true here. ([LocationÂ 3518](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3518)) #âœ‚ï¸ 
{ #ref-537090528}


---
>[!QUOTE]  
>If you ask others to estimate an activity, you must maintain a correct estimation dialog with them. Never dictate duration by saying, â€œYou have two weeks!â€ Not only is that based on nothing, but the owner of the activity also does not feel accountable to actually finish in two weeks. When people are unaccountable, progress and quality will be lacking. Avoid leading questions, such as â€œIt is going to take two weeks, right?â€ While this is somewhat better than dictating the estimation, you now bias the other party toward your estimation. ([LocationÂ 3533](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3533)) #âœ‚ï¸ 
{ #ref-537090529}


---
##### Critical Path Analysis
>[!QUOTE]  
>Critical path analysis is the single most important project design technique. However, you cannot perform this analysis without the following prerequisites: The system architecture. You must have the decomposition of the system into services and other building blocks such as Clients and Managers ([LocationÂ 3542](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3542)) #âœ‚ï¸ 
{ #ref-537090530}


---
>[!QUOTE]  
>A list of all project activities. Your list must contain both coding and noncoding activities. ([LocationÂ 3547](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3547)) #âœ‚ï¸ 
{ #ref-537090531}


---
>[!QUOTE]  
>Activity effort estimation. Have an accurate estimation of the effort for each activity in the list of activities. ([LocationÂ 3550](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3550)) #âœ‚ï¸ 
{ #ref-537090532}


---
>[!QUOTE]  
>Services dependency tree. Use the call chains to identify the dependencies between the various services in the architecture. ([LocationÂ 3551](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3551)) #âœ‚ï¸ 
{ #ref-537090533}


---
>[!QUOTE]  
>Activity dependencies. Beyond the dependencies between your services, you must compile a list of how all activities depend on other activities, coding and noncoding alike. ([LocationÂ 3552](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3552)) #âœ‚ï¸ 
{ #ref-537090534}


---
>[!QUOTE]  
>Planning assumptions. You must know the resources available for the project or, more correctly, the staffing scenarios that your plan calls for. ([LocationÂ 3554](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3554)) #âœ‚ï¸ 
{ #ref-537090535}


---
>[!QUOTE]  
>You can graphically arrange the activities in the project into a network diagram. The network diagram shows all activities in the project and their dependencies. You first derive the activity dependencies from the way the call chains propagate through the system. ([LocationÂ 3558](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3558)) #âœ‚ï¸ 
{ #ref-537090536}


---
>[!QUOTE]  
>You should turn the diagram in Figure 7-4 into the detailed abstract chart shown in Figure 7-5. That chart now contains all activities, coding and noncoding alike, such as architecture and system testing. ([LocationÂ 3573](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3573)) #âœ‚ï¸ 
{ #ref-537090537}


---
>[!QUOTE]  
>The time to get to an activity, or the time it takes to be ready to start working on the activity, is the maximum of time of all network paths leading to that activity. In a more formal manner, you calculate the time for completing activity i in the project with this recursive formula: where: Ti is the time for completing activity i. Ei is the effort estimation for activity i. n is the number of activities leading directly to activity i. ([LocationÂ 3580](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3580)) #âœ‚ï¸ 
{ #ref-537090538}


---
>[!QUOTE]  
>By calculating the activity times, you can identify the longest possible path in the network of activities. In this context, the longest path means the path with greatest duration, not necessarily the one with the greatest number of activities. ([LocationÂ 3606](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3606)) #âœ‚ï¸ 
{ #ref-537090539}


---
>[!QUOTE]  
>Based on the effort estimation for each activity and the dependencies, using the formula given earlier and starting from activity 17, the longest path in the network is shown in bold. That longest path in the network is called the critical path. ([LocationÂ 3611](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3611)) #âœ‚ï¸ 
{ #ref-537090540}


---
>[!QUOTE]  
>With so few developers, you will paint yourself into a corner in which a developer on the critical path needs a noncritical activity that is simply not ready yet (such as activity 15 needing activity 11). This promotes a noncritical activity to a critical activity, in effect creating a new and longer critical path. I call this situation subcritical staffing. When the project goes subcritical, it will miss its deadline because the old critical path no longer applies. ([LocationÂ 3659](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3659)) #âœ‚ï¸ 
{ #ref-537739160}


---
>[!QUOTE]  
>All noncritical activities have float, which is the amount of time you could delay completing them without delaying the project. Critical activities have no float (or more precisely, their float is zero) since any delay in these activities would delay the project. When you assign resources to the project, follow this rule: Always assign resources based on float. ([LocationÂ 3691](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3691)) #âœ‚ï¸ 
{ #ref-537739161}


---
##### Scheduling Activities
>[!QUOTE]  
>Together, the project network, the critical path, and the float analysis allow you to calculate the duration of the project as well as when each activity should start with respect to the project beginning. ([LocationÂ 3760](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3760)) #âœ‚ï¸ 
{ #ref-537739162}


---
>[!QUOTE]  
>If you have several projects in the organization, then you could arrange them such that developers are always phasing out of one project while phasing into another. Working this way yields a hundreds of percent increase in productivity, the classic â€œdoing much more with less.â€ ([LocationÂ 3780](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3780)) #âœ‚ï¸ #disagree 
{ #ref-537739163}


---
>[!QUOTE]  
>You produce a chart such as Figure 7-9 by first staffing the project, then listing all the dates of interest (unique dates when activities start and end) in chronological order. You then count how many resources are required for each category of resources in each time period between dates of interest. ([LocationÂ 3797](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3797)) #âœ‚ï¸ 
{ #ref-537739164}


---
##### Project Cost
>[!QUOTE]  
>The efficiency of a project is the ratio between the sum of effort across all activities (assuming perfect utilization of people) and the actual project cost. ([LocationÂ 3889](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3889)) #âœ‚ï¸ 
{ #ref-537739165}


---
>[!QUOTE]  
>The expected efficiency of a well-designed system, along with a properly designed and staffed project, ranges between 15% and 25%. ([LocationÂ 3893](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3893)) #âœ‚ï¸ 
{ #ref-537739166}


---
##### Earned Value Planning
>[!QUOTE]  
>The earned value at time t is the ratio between the sum of estimated duration of all activities completed by time t divided by the sum of the estimated durations of all activities. ([LocationÂ 3930](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=3930)) #âœ‚ï¸ 
{ #ref-537739167}


---
>[!QUOTE]  
>The earned value curve is a simple and easy way to answer the question: â€œDoes the plan make sense?â€ If the planned earned value is a straight line, or it exhibits the issues of Figure 7-20 or Figure 7-22, the project is in danger. If it looks like a shallow S, then at least you have hope that the plan is sound and sensible. ([LocationÂ 4014](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4014)) #âœ‚ï¸ 
{ #ref-537739168}


---
##### Roles and Responsibilities
#### 8. Network and Float
>[!QUOTE]  
>The project network acts as a logical representation of the project for planning purposes. The technique for analyzing the network is called the critical path method, although it has as much to do with the noncritical activities as it does with the critical ones. ([LocationÂ 4038](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4038)) #âœ‚ï¸ 
{ #ref-538480695}


---
##### The Network Diagram
>[!QUOTE]  
>An activity in a software project is any task that requires both time and a resource. ([LocationÂ 4047](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4047)) #âœ‚ï¸ 
{ #ref-538480696}


---
>[!QUOTE]  
>The project is a collection of related activities, and the network diagram captures these activities and their dependencies. In network diagrams, there is no notion of order of execution or concurrency between the activities. ([LocationÂ 4048](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4048)) #âœ‚ï¸ 
{ #ref-538480697}


---
>[!QUOTE]  
>Consequently, you should avoid node diagrams and use arrow diagrams. The initial arrow diagram learning curve is more than offset by the benefits of having a concise, clear, clutter-free model of your project. ([LocationÂ 4116](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4116)) #âœ‚ï¸ 
{ #ref-538480698}


---
##### Floats
>[!QUOTE]  
>An activityâ€™s total float is by how much time you can delay the completion of that activity without delaying the project as a whole. ([LocationÂ 4151](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4151)) #âœ‚ï¸ 
{ #ref-538480699}


---
>[!QUOTE]  
>An activityâ€™s free float is by how much time you can delay the completion of that activity without disturbing any other activity in the project. ([LocationÂ 4169](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4169)) #âœ‚ï¸ 
{ #ref-538480700}


---
##### Floats-Based Scheduling
>[!QUOTE]  
>As stated in Chapter 7, the safest and most efficient way to assign resources to activities is based on floatâ€”or, given the definition of this chapter, total float. This is the safest method because you address the riskier activities first, and it is the most efficient because you maximize the percentage of time for which the resources are utilized. ([LocationÂ 4243](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4243)) #âœ‚ï¸ 
{ #ref-538480701}


---
>[!QUOTE]  
>As just stated, assigning resources based on float allows you to trade float for cost. You may be tempted to trade all the projectâ€™s float for lower cost, but that is rarely a good idea because a project with little float has less tolerance for delays. ([LocationÂ 4289](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4289)) #âœ‚ï¸ 
{ #ref-538480702}


---
#### 9. Time and Cost
##### Accelerating Software Projects
>[!QUOTE]  
>In general, the following techniques are possible in any software project and will accelerate the project as a whole: Assure quality. ([LocationÂ 4306](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4306)) #âœ‚ï¸ 
{ #ref-538480703}


---
>[!QUOTE]  
>Employ test engineers. ([LocationÂ 4314](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4314)) #âœ‚ï¸ 
{ #ref-538480704}


---
>[!QUOTE]  
>Add software testers. ([LocationÂ 4322](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4322)) #âœ‚ï¸ 
{ #ref-538480705}


---
>[!QUOTE]  
>Invest in infrastructure. ([LocationÂ 4327](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4327)) #âœ‚ï¸ 
{ #ref-538480706}


---
>[!QUOTE]  
>Improve development skills. ([LocationÂ 4332](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4332)) #âœ‚ï¸ 
{ #ref-538480707}


---
>[!QUOTE]  
>Improve the process. ([LocationÂ 4339](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4339)) #âœ‚ï¸ 
{ #ref-538480708}


---
>[!QUOTE]  
>Adopt and employ standards. ([LocationÂ 4346](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4346)) #âœ‚ï¸ 
{ #ref-538480709}


---
>[!QUOTE]  
>Provide access to external experts. ([LocationÂ 4350](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4350)) #âœ‚ï¸ 
{ #ref-538480710}


---
>[!QUOTE]  
>Engage in peer reviews. ([LocationÂ 4355](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4355)) #âœ‚ï¸ 
{ #ref-538480711}


---
##### Schedule Compression
>[!QUOTE]  
>However, you can do two things to immediately accelerate the scheduleâ€”either work with better resources or find ways of working in parallel. ([LocationÂ 4370](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4370)) #âœ‚ï¸ 
{ #ref-538480712}


---
>[!QUOTE]  
>Schedule compression means accomplishing the same objectives faster, often by doing more work to finish the task or the project sooner. You can use these two compression techniques in combination with each other or in isolation, on parts of the project, on the project as a whole, or on individual activities. Both compression techniques end up increasing the direct cost (defined later) of the project while reducing the schedule. ([LocationÂ 4372](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4372)) #âœ‚ï¸ 
{ #ref-538480713}


---
>[!QUOTE]  
>Removing dependencies often involves investing in additional activities that enable the parallel work in the first place: Contract design. ([LocationÂ 4405](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4405)) #âœ‚ï¸ 
{ #ref-538480714}


---
>[!QUOTE]  
>Emulators development. ([LocationÂ 4409](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4409)) #âœ‚ï¸ 
{ #ref-538480715}


---
>[!QUOTE]  
>Simulators development. ([LocationÂ 4411](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4411)) #âœ‚ï¸ 
{ #ref-538480716}


---
>[!QUOTE]  
>Repeated integration and testing. ([LocationÂ 4414](https://readwise.io/to_kindle?action=open&asin=B0822XJZ48&location=4414)) #âœ‚ï¸ 
{ #ref-538480717}


---
##### Timeâ€“Cost Curve
##### Avoiding Classic Mistakes
##### Project Cost Elements
##### Network Compression
#### 10. Risk
##### Choosing Options
##### Timeâ€“Risk Curve
##### Risk Modeling
##### Compression and Risk
##### Risk Decompression
##### Risk Metrics
#### 11. Project Design in Action
##### The Mission
##### Finding the Normal Solution
##### Network Compression
##### Efficiency Analysis
##### Timeâ€“Cost Curve
##### Planning and Risk
##### SDP Review
#### 12. Advanced Techniques
##### God Activities
##### Risk Crossover Point
##### Finding the Decompression Target
##### Geometric Risk
##### Execution Complexity
##### Very Large Projects
##### Small Projects
##### Design by Layers
#### 13. Project Design Example
##### Dependencies and Project Network
##### The Normal Solution
##### Compressed Solution
##### Design by Layers
##### Subcritical Solution
##### Comparing the Options
##### Planning and Risk
##### Preparing for the SDP Review
#### 14. Concluding Thoughts
##### When to Design a Project
##### General Guidelines
##### Design of Project Design
##### In Perspective
##### The Hand-Off
##### In Practice
##### Debriefing Project Design
##### About Quality
### Appendices
#### A. Project Tracking
##### Activity Life Cycle and Status
##### Project Status
##### Tracking Progress and Effort
##### Projections and Corrective Actions
##### More on Projections
#### B. Service Contract Design
##### Is This a Good Design?
##### Modularity and Cost
##### Services and Contracts
##### Factoring Contracts
##### Contract Design Metrics
##### The Contract Design Challenge
#### C. Design Standard
##### The Prime Directive
##### Directives
##### System Design Guidelines
##### Project Design Guidelines
##### Project Tracking Guidelines
##### Service Contract Design Guidelines

